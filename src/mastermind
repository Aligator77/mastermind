#!/usr/bin/python
import os
import re
import subprocess
from time import sleep
from functools import wraps

import msgpack

from opster import Dispatcher
from cocaine.services import Service


SERVICE_APP_NAME = 'mastermind'
SERVICE_DEFAULT_HOST = 'localhost'
SERVICE_DEFAULT_PORT = 10053

host_param = ['h',
              'host',
              '{host}:{port}'.format(host=SERVICE_DEFAULT_HOST,
                                     port=SERVICE_DEFAULT_PORT),
              'Mastermind application host[:port]']


def service(host):
    parts = host.split(':', 1)
    hostname, port = parts[0], len(parts) == 2 and int(parts[1]) or SERVICE_DEFAULT_PORT
    return Service(SERVICE_APP_NAME, host=hostname, port=port)


# group commands
groupDispatcher = Dispatcher(globaloptions=(host_param,))


@groupDispatcher.command(name='info')
def group_info(group, history=('l', False, 'History of group nodes'), host=None):
    '''Get group info'''
    s = service(host)
    group = int(group)

    res = s.enqueue("get_group_info", msgpack.packb(group)).get()
    print res

    if history:

        print "\nHistory:"

        group_history = s.enqueue('get_group_history', msgpack.packb([group])).get()
        if isinstance(group_history, dict):
            # exception returned
            print group_history
        else:
            for entry in group_history:
                print '[%s] %s' % (entry['timestamp'], entry['set'])


@groupDispatcher.command(name='next-number')
def group_next_number(count, host=None):
    '''Get unused group numbers, number of groups is an argument'''
    s = service(host)
    count = int(count)

    res = s.enqueue("get_next_group_number", msgpack.packb(count)).get()
    print res


@groupDispatcher.command(name='list-uncoupled')
def group_list_uncoupled(host=None):
    '''Get list of uncoupled groups from balancer'''
    s = service(host)
    res = s.enqueue("get_empty_groups", "").get()
    print res


# couple commands
coupleDispatcher = Dispatcher(globaloptions=(host_param,))


@coupleDispatcher.command(name='list-bad')
def couple_list_bad(host=None):
    '''Get list of broken couples from balancer'''
    s = service(host)
    res = s.enqueue("get_bad_groups", "").get()
    print res


@coupleDispatcher.command(name='list-symmetric')
def couple_list_symmetric(host=None):
    '''Get list of good couples from balancer'''
    s = service(host)
    res = s.enqueue("get_symmetric_groups", "").get()
    print res


@coupleDispatcher.command(name='list-frozen')
def couple_list_frozen(host=None):
    '''Get list of good couples from balancer'''
    s = service(host)
    res = s.enqueue("get_frozen_groups", "").get()
    print res


@coupleDispatcher.command(name='list-closed')
def couple_list_closed(host=None):
    '''Get list of couples closed to balancer'''
    s = service(host)
    res = s.enqueue('get_closed_groups', '').get()
    print res


@coupleDispatcher.command(name='build')
def couple_build(size, groups=('i', '', 'Use these groups in couple (example: 1:2)'),
                 namespace=('n', '', 'Set custom namespace for couple'), host=None):
    '''Make a couple of groups, number of groups is an argument'''
    s = service(host)
    size = int(size)
    if groups:
        groups = [int(g) for g in groups.split(':')]
    else:
        groups = []

    params = [size, groups]
    if namespace:
        params.append(namespace)

    res = s.enqueue("couple_groups", msgpack.packb(tuple(params))).get()
    print res


@coupleDispatcher.command(name='break')
def couple_break(groups, confirm, host=None):
    '''Break the couple of groups, couple is an argument
        confirm parameter is a message "Yes, I want to break (bad|good) couple [1:2:3]"'''
    s = service(host)
    groups = [int(g) for g in groups.split(':')]

    res = s.enqueue("break_couple", msgpack.packb((groups, confirm))).get()
    print res


@coupleDispatcher.command(name='balance')
def couple_balance(size, host=None):
    '''Get couple balance'''
    s = service(host)
    size = int(size)
    id = [0] * 64

    res = s.enqueue("balance", msgpack.packb((size, 1, id))).get()
    print res


@coupleDispatcher.command(name='weights')
def couple_get_weights(host=None):
    '''Get weights for symmetric groups'''
    s = service(host)
    res = s.enqueue("get_group_weights", "").get()
    print res


@coupleDispatcher.command(name='repair')
def couple_repair(group,
                  namespace=('n', '', 'Use namespace for couple if there are '
                                      'no neighbour groups to fetch definite namespace'),
                  host=None):
    '''Repair broken symmetric groups'''
    s = service(host)
    params = [int(group)]
    if namespace:
        params.append(namespace)

    res = s.enqueue("repair_groups", msgpack.packb(tuple(params))).get()
    print res


# cache commands
cacheDispatcher = Dispatcher(globaloptions=(host_param,))


@cacheDispatcher.command(name='keys')
def cache_keys(host=None):
    '''Fetch cached keys'''
    s = service(host)

    res = s.enqueue('get_cached_keys', '').get()
    print res


@cacheDispatcher.command(name='keys-by-group')
def cache_keys_by_group(group, host=None):
    '''Fetch cached keys for certain group id'''
    s = service(host)
    group = int(group)

    res = s.enqueue('get_cached_keys_by_group', msgpack.packb(group)).get()

@coupleDispatcher.command(name='freeze')
def couple_freeze(couple, host=None):
    '''Freeze symmetric group (freeze couples are excluded from balancing)'''
    s = service(host)
    groups = [int(g) for g in couple.split(':')]

    res = s.enqueue('freeze_couple', msgpack.packb(groups)).get()
    print res


@coupleDispatcher.command(name='unfreeze')
def couple_unfreeze(couple, host=None):
    '''Unfreeze symmetric group'''
    s = service(host)
    groups = [int(g) for g in couple.split(':')]

    res = s.enqueue('unfreeze_couple', msgpack.packb(groups)).get()
    print res


# cmd commands
cmdDispatcher = Dispatcher(globaloptions=(host_param,))


DEFAULT = '\033[0m'
RED = '\033[1;31m'
GREEN = '\033[1;32m'

def warn(s):
    return '{color}{text}{coloroff}'.format(color=RED,
                                            text=s, coloroff=DEFAULT)

def highlight(s):
    return '{color}{text}{coloroff}'.format(color=GREEN,
                                            text=s, coloroff=DEFAULT)

def box(text, caption=None):
    print
    print '=' * 8 + (' %s ' % caption) + '=' * (60 - (len(caption) + 10))
    print highlight(text)
    print '=' * 60
    print


PATH_RE = re.compile('/[^\s]*')
MIN_PATH_LENGTH = 7


def danger(cmd):
    for path in PATH_RE.findall(cmd):
        if len(path) < MIN_PATH_LENGTH:
            return True
    return False


def confirm(prompt, answer, prefix=''):
    if prefix:
        print prefix

    try:
        s = raw_input(prompt)
    except KeyboardInterrupt:
        s = ''
        print

    return s == answer


@cmdDispatcher.command(name='restore')
def restore_group(group, user=('u', os.getlogin(), 'rsync command user'),
                  dest=('d', '', 'Destination path on current host for rsync command'),
                  host=None):
    '''Fetch cached keys'''
    s = service(host)
    group = int(group)

    res = s.enqueue('restore_group_cmd', msgpack.packb([group, user, dest])).get()
    if isinstance(res, dict):
        print res
        return

    cmd, messages = res
    for msg in messages:
        print '{prefix} {msg}'.format(prefix=warn('WARNING:'), msg=msg)

    if not cmd:
        return

    box(cmd, caption='Command')

    if not confirm('Do you want the glorious mastermind '
                   'to execute this command for you? [yes/no]: ', 'yes'):
        print 'Like a pussy...'
        return

    if danger(cmd):

        test_msg = 'God please forgive me'

        if not confirm('I will execute it for you, though, '
                       'if you type "%s": ' % test_msg, test_msg,
                       prefix='Hmm... The command seems pretty strange to me.'):
             print 'I thought so...'
             return

        print 'Well if you say so...\n'

    try:
        retval = subprocess.call(cmd.split(' '))
    except KeyboardInterrupt:
        print 'Command execution was manually interrupted'
        return

    if retval:
        print 'Failed to execute command, return value: %s' % retval
        return

    print "Good boy!"


d = Dispatcher()
d.nest('group', groupDispatcher, 'Perform group action')
d.nest('couple', coupleDispatcher, 'Perform couple action')
d.nest('cache', cacheDispatcher, 'Perform cache action')
d.nest('cmd', cmdDispatcher, 'Some useful commands')


if __name__ == '__main__':
    d.dispatch()
